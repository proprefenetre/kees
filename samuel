#!/usr/bin/env python
# -*- coding: utf-8 -*-

import argparse
from bs4 import BeautifulSoup 
from re import sub
from urllib.request import urlopen, Request
from urllib.parse import quote


SEARCH_URL = 'http://www.mijnwoordenboek.nl/vertaal/{source}/{target}/{word}'
LANGUAGES = ['NL', 'EN', 'DE', 'FR', 'ES']

TARGET_DIV = '.span8 > div:nth-of-type(1)'
FONT_STYLE = 'color:navy;font-size:10pt'


def _get_response(url):
    # try
    return urlopen(url)
    # TODO: valid errorcatching
    # except SomeError as e:
        # raise e


def _get_soup(args):
    response = _get_response(SEARCH_URL.format_map(args))
    return BeautifulSoup(response, 'lxml')


def _get_translations(soup):
    div = soup.select(TARGET_DIV + '> font') 
    return [word for group in [elem.text.split(',') for elem in div
            if FONT_STYLE in elem['style']] for word in group]


def _get_other_sources(soup):
    tables = soup.select(TARGET_DIV + '> table')
    other_sources = []
    for t in tables:
        if t.get('border', None) is not None:
            for td in t('td'):
                if td.get('style', None) is not None:
                    other_sources.extend([w for w in
                                          td.text.split(';')])
    return other_sources

# TODO: simplify 
def uniek(words):
    words = [w.split() for w in words]
    det = []
    no_det = []
    for w in words:
        if len(w) < 2:
            no_det.append(w)
        else:
            det.append(w)
    
    for x in no_det:
        if x[0] not in [v[1] for v in det]:
            det.append(x[0])
        else:
            continue
    return [' '.join(d) for d in det]


def _process(trs):
    result = []
    for t in trs:
        stripped = t.strip()
        subbed = sub(r'\s+[\(].*[\)]', '', stripped)
        result.append(subbed)
    return uniek(result)


def _parse_elements(args):
    soup = _get_soup(args)   
    translations = _process(_get_translations(soup) + _get_other_sources(soup))
    return set(translations)


def english_motherfucker(args):
    args['word'] = quote(' '.join(args['word']).strip())
    args['source'] = 'NL'

    trs = list(_parse_elements(args))

    if not args['target'] in LANGUAGES:
        raise ValueError('{} - {} not available'.format(args['source'],
                                                        args['target']))

    if args['sort']:
        trs.sort()

    print('{}: ({} translations)'.format(args['word'], len(trs)))
    num = args.get('num_translations', len(trs))
    for idx, word in enumerate(trs):
        pad = 2 if idx+1 < 10 else 3
        print('{:.<{}} {:<10}'.format(idx+1, pad, word))
        if idx+1 == num:
            break
    print()


def get_parser():
    parser = argparse.ArgumentParser(description='English, motherfucker! \
                                     Do you speak it?!')
    parser.add_argument('word', metavar='WORD', type=str, nargs='+',
                        help='word to be translated')
    parser.add_argument('-s', '--sort', action='store_true',
                        help='sort translations alphabetically')
    parser.add_argument('-t', '--target', type=str, default='EN',
                        help='target language (EN, DE, FR, SP; default: EN)')
    parser.add_argument('-n', '--num-translations', type=int,
                        help='number of translations')
    return parser


def run():
    p = get_parser()
    args = vars(p.parse_args())
    english_motherfucker(args)

if __name__ == "__main__":
    run()

# vim: ft=python
